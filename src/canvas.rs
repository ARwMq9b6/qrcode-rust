//! The `canvas` module puts raw bits into the QR code canvas.
//!
//!     use qrcode::types::{Version, L};
//!     use qrcode::canvas::{Canvas, Checkerboard};
//!
//!     let mut c = Canvas::new(Version(1), L);
//!     c.draw_all_functional_patterns();
//!     c.draw_data(b"data_here", b"ec_code_here");
//!     c.apply_mask(Checkerboard);
//!     let bools = c.to_bools();

use std::iter::range_inclusive;
use std::iter::order::equals;
use std::num::zero;
use std::cmp::max;

use types::{Version, MicroVersion, ErrorCorrectionLevel, L, M, Q};

//------------------------------------------------------------------------------
//{{{ Modules

/// The color of a module (pixel) in the QR code.
#[deriving(PartialEq, Eq, Clone, Copy, Show)]
pub enum Module {
    /// The module is empty.
    Empty,

    /// The module is light (white), and cannot be masked. This mainly refers to
    /// modules of functional patterns.
    Light,

    /// The module is dark (black), and cannot be masked. This mainly refers to
    /// modules of functional patterns.
    Dark,

    /// The module is light (white), but not yet masked. This mainly refers to
    /// modules of data and error correction bits before masking.
    LightUnmasked,

    /// The module is dark (black), but not yet masked. This mainly refers to
    /// modules of data and error correction bits before masking.
    DarkUnmasked,
}

impl Module {
    /// Checks whether a module is dark.
    pub fn is_dark(&self) -> bool {
        match *self {
            Dark | DarkUnmasked => true,
            _ => false,
        }
    }

    /// Apply a mask to the unmasked modules.
    ///
    ///     use qrcode::canvas::{LightUnmasked, Light, DarkUnmasked, Dark};
    ///
    ///     assert_eq!(LightUnmasked.mask(true), Dark);
    ///     assert_eq!(DarkUnmasked.mask(true), Light);
    ///     assert_eq!(LightUnmasked.mask(false), Light);
    ///     assert_eq!(Dark.mask(true), Dark);
    ///     assert_eq!(Dark.mask(false), Dark);
    ///
    pub fn mask(&self, should_invert: bool) -> Module {
        match (*self, should_invert) {
            (Empty, true) | (LightUnmasked, true) => Dark,
            (Empty, false) | (LightUnmasked, false) => Light,
            (DarkUnmasked, true) => Light,
            (DarkUnmasked, false) => Dark,
            (a, _) => a,
        }
    }
}

//}}}
//------------------------------------------------------------------------------
//{{{ Canvas

/// `Canvas` is an intermediate helper structure to render error-corrected data
/// into a QR code.
#[deriving(Clone)]
pub struct Canvas {
    /// The width and height of the canvas (cached as it is needed frequently).
    width: i16,

    /// The version of the QR code.
    version: Version,

    /// The error correction level of the QR code.
    ec_level: ErrorCorrectionLevel,

    /// The modules of the QR code. Modules are arranged in left-to-right, then
    /// top-to-bottom order.
    modules: Vec<Module>,
}

impl Canvas {
    /// Constructs a new canvas big enough for a QR code of the given version.
    pub fn new(version: Version, ec_level: ErrorCorrectionLevel) -> Canvas {
        let width = version.width();
        Canvas {
            width: width,
            version: version,
            ec_level: ec_level,
            modules: Vec::from_elem((width*width) as uint, Empty),
        }
    }

    /// Converts the canvas into a human-readable string.
    #[cfg(test)]
    fn to_debug_str(&self) -> String {
        let width = self.width;
        let mut res = String::with_capacity((width * (width + 1)) as uint);
        for y in range(0, width) {
            res.push_char('\n');
            for x in range(0, width) {
                res.push_char(match self.get(x, y) {
                    Empty => '?',
                    Light => '.',
                    Dark => '#',
                    LightUnmasked => '-',
                    DarkUnmasked => '*',
                });
            }
        }
        res
    }

    fn coords_to_index(&self, x: i16, y: i16) -> uint {
        let x = if x < 0 { x + self.width } else { x } as uint;
        let y = if y < 0 { y + self.width } else { y } as uint;
        y * (self.width as uint) + x
    }

    /// Obtains a module at the given coordinates. For convenience, negative
    /// coordinates will wrap around.
    pub fn get(&self, x: i16, y: i16) -> Module {
        self.modules[self.coords_to_index(x, y)]
    }

    /// Obtains a mutable module at the given coordinates. For convenience,
    /// negative coordinates will wrap around.
    pub fn get_mut<'a>(&'a mut self, x: i16, y: i16) -> &'a mut Module {
        let index = self.coords_to_index(x, y);
        self.modules.get_mut(index)
    }

    /// Sets the color of a module at the given coordinates. For convenience,
    /// negative coordinates will wrap around.
    pub fn put(&mut self, x: i16, y: i16, module: Module) {
        *self.get_mut(x, y) = module;
    }

}

#[cfg(test)]
mod basic_canvas_tests {
    use canvas::{Canvas, Empty, Dark, Light, DarkUnmasked, LightUnmasked};
    use types::{Version, L};

    #[test]
    fn test_index() {
        let mut c = Canvas::new(Version(1), L);

        assert_eq!(c.get(0, 4), Empty);
        assert_eq!(c.get(-1, -7), Empty);
        assert_eq!(c.get(21-1, 21-7), Empty);

        c.put(0, 0, Dark);
        c.put(-1, -7, Light);
        assert_eq!(c.get(0, 0), Dark);
        assert_eq!(c.get(21-1, -7), Light);
        assert_eq!(c.get(-1, 21-7), Light);
    }

    #[test]
    fn test_debug_str() {
        let mut c = Canvas::new(Version(1), L);

        for i in range(3i16, 20) {
            for j in range(3i16, 20) {
                c.put(i, j, match ((i * 3) ^ j) % 5 {
                    0 => Empty,
                    1 => Light,
                    2 => Dark,
                    3 => LightUnmasked,
                    4 => DarkUnmasked,
                    _ => fail!(),
                });
            }
        }

        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????####****....---?\n\
                    ???--.##-..##?..#??.?\n\
                    ???#*?-.*?#.-*#?-*.??\n\
                    ?????*?*?****-*-*---?\n\
                    ???*.-.-.-?-?#?#?#*#?\n\
                    ???.*#.*.*#.*#*#.*#*?\n\
                    ?????.#-#--??.?.#---?\n\
                    ???-.?*.-#?-.?#*-#?.?\n\
                    ???##*??*..##*--*..??\n\
                    ?????-???--??---?---?\n\
                    ???*.#.*.#**.#*#.#*#?\n\
                    ???##.-##..##..?#..??\n\
                    ???.-?*.-?#.-?#*-?#*?\n\
                    ????-.#?-.**#?-.#?-.?\n\
                    ???**?-**??--**?-**??\n\
                    ???#?*?#?*#.*-.-*-.-?\n\
                    ???..-...--??###?###?\n\
                    ?????????????????????");
    }
}

//}}}
//------------------------------------------------------------------------------
//{{{ Finder patterns

impl Canvas {
    /// Draws a single finder pattern with the center at (x, y).
    fn draw_finder_pattern_at(&mut self, x: i16, y: i16) {
        let (dx_left, dx_right) = if x >= 0 { (-3, 4) } else { (-4, 3) };
        let (dy_top, dy_bottom) = if y >= 0 { (-3, 4) } else { (-4, 3) };
        for j in range_inclusive(dy_top, dy_bottom) {
            for i in range_inclusive(dx_left, dx_right) {
                self.put(x+i, y+j, match (i, j) {
                    (4, _) | (_, 4) | (-4, _) | (_, -4) => Light,
                    (3, _) | (_, 3) | (-3, _) | (_, -3) => Dark,
                    (2, _) | (_, 2) | (-2, _) | (_, -2) => Light,
                    _ => Dark,
                });
            }
        }
    }

    /// Draws the finder patterns.
    ///
    /// The finder patterns is are 7Ã—7 square patterns appearing at the three
    /// corners of a QR code. They allows scanner to locate the QR code and
    /// determine the orientation.
    fn draw_finder_patterns(&mut self) {
        self.draw_finder_pattern_at(3, 3);

        match self.version {
            MicroVersion(_) => { return; }
            Version(_) => {
                self.draw_finder_pattern_at(-4, 3);
                self.draw_finder_pattern_at(3, -4);
            }
        }
    }
}

#[cfg(test)]
mod finder_pattern_tests {
    use canvas::Canvas;
    use types::{Version, MicroVersion, L};

    #[test]
    fn test_qr() {
        let mut c = Canvas::new(Version(1), L);
        c.draw_finder_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######.?????.#######\n\
                    #.....#.?????.#.....#\n\
                    #.###.#.?????.#.###.#\n\
                    #.###.#.?????.#.###.#\n\
                    #.###.#.?????.#.###.#\n\
                    #.....#.?????.#.....#\n\
                    #######.?????.#######\n\
                    ........?????........\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ........?????????????\n\
                    #######.?????????????\n\
                    #.....#.?????????????\n\
                    #.###.#.?????????????\n\
                    #.###.#.?????????????\n\
                    #.###.#.?????????????\n\
                    #.....#.?????????????\n\
                    #######.?????????????");
    }

    #[test]
    fn test_micro_qr() {
        let mut c = Canvas::new(MicroVersion(1), L);
        c.draw_finder_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######.???\n\
                    #.....#.???\n\
                    #.###.#.???\n\
                    #.###.#.???\n\
                    #.###.#.???\n\
                    #.....#.???\n\
                    #######.???\n\
                    ........???\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????");
    }
}

//}}}
//------------------------------------------------------------------------------
//{{{ Alignment patterns

impl Canvas {
    /// Draws a alignment pattern with the center at (x, y).
    fn draw_alignment_pattern_at(&mut self, x: i16, y: i16) {
        if self.get(x, y) != Empty {
            return;
        }
        for j in range_inclusive(-2, 2) {
            for i in range_inclusive(-2, 2) {
                self.put(x+i, y+j, match (i, j) {
                    (2, _) | (_, 2) | (-2, _) | (_, -2) | (0, 0) => Dark,
                    _ => Light,
                });
            }
        }
    }

    /// Draws the alignment patterns.
    ///
    /// The alignment patterns are 5Ã—5 square patterns inside the QR code symbol
    /// to help the scanner create the square grid.
    fn draw_alignment_patterns(&mut self) {
        match self.version {
            MicroVersion(_) | Version(1) => { return; }
            Version(2..6) => self.draw_alignment_pattern_at(-7, -7),
            Version(a) => {
                let positions = ALIGNMENT_PATTERN_POSITIONS[a as uint - 7];
                for x in positions.iter() {
                    for y in positions.iter() {
                        self.draw_alignment_pattern_at(*x, *y);
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod alignment_pattern_tests {
    use canvas::Canvas;
    use types::{Version, L};

    #[test]
    fn test_draw_alignment_patterns_1() {
        let mut c = Canvas::new(Version(1), L);
        c.draw_finder_patterns();
        c.draw_alignment_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######.?????.#######\n\
                    #.....#.?????.#.....#\n\
                    #.###.#.?????.#.###.#\n\
                    #.###.#.?????.#.###.#\n\
                    #.###.#.?????.#.###.#\n\
                    #.....#.?????.#.....#\n\
                    #######.?????.#######\n\
                    ........?????........\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ........?????????????\n\
                    #######.?????????????\n\
                    #.....#.?????????????\n\
                    #.###.#.?????????????\n\
                    #.###.#.?????????????\n\
                    #.###.#.?????????????\n\
                    #.....#.?????????????\n\
                    #######.?????????????");
    }

    #[test]
    fn test_draw_alignment_patterns_3() {
        let mut c = Canvas::new(Version(3), L);
        c.draw_finder_patterns();
        c.draw_alignment_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######.?????????????.#######\n\
                    #.....#.?????????????.#.....#\n\
                    #.###.#.?????????????.#.###.#\n\
                    #.###.#.?????????????.#.###.#\n\
                    #.###.#.?????????????.#.###.#\n\
                    #.....#.?????????????.#.....#\n\
                    #######.?????????????.#######\n\
                    ........?????????????........\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ?????????????????????????????\n\
                    ????????????????????#####????\n\
                    ........????????????#...#????\n\
                    #######.????????????#.#.#????\n\
                    #.....#.????????????#...#????\n\
                    #.###.#.????????????#####????\n\
                    #.###.#.?????????????????????\n\
                    #.###.#.?????????????????????\n\
                    #.....#.?????????????????????\n\
                    #######.?????????????????????");
    }

    #[test]
    fn test_draw_alignment_patterns_7() {
        let mut c = Canvas::new(Version(7), L);
        c.draw_finder_patterns();
        c.draw_alignment_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######.?????????????????????????????.#######\n\
                    #.....#.?????????????????????????????.#.....#\n\
                    #.###.#.?????????????????????????????.#.###.#\n\
                    #.###.#.?????????????????????????????.#.###.#\n\
                    #.###.#.????????????#####????????????.#.###.#\n\
                    #.....#.????????????#...#????????????.#.....#\n\
                    #######.????????????#.#.#????????????.#######\n\
                    ........????????????#...#????????????........\n\
                    ????????????????????#####????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ????#####???????????#####???????????#####????\n\
                    ????#...#???????????#...#???????????#...#????\n\
                    ????#.#.#???????????#.#.#???????????#.#.#????\n\
                    ????#...#???????????#...#???????????#...#????\n\
                    ????#####???????????#####???????????#####????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ????????????????????#####???????????#####????\n\
                    ........????????????#...#???????????#...#????\n\
                    #######.????????????#.#.#???????????#.#.#????\n\
                    #.....#.????????????#...#???????????#...#????\n\
                    #.###.#.????????????#####???????????#####????\n\
                    #.###.#.?????????????????????????????????????\n\
                    #.###.#.?????????????????????????????????????\n\
                    #.....#.?????????????????????????????????????\n\
                    #######.?????????????????????????????????????");
    }
}


/// `ALIGNMENT_PATTERN_POSITIONS` describes the x- and y-coordinates of the
/// center of the alignment patterns. Since the QR code is symmetric, only one
/// coordinate is needed.
static ALIGNMENT_PATTERN_POSITIONS: [&'static [i16], ..34] = [
    &[6, 22, 38],
    &[6, 24, 42],
    &[6, 26, 46],
    &[6, 28, 50],
    &[6, 30, 54],
    &[6, 32, 58],
    &[6, 34, 62],
    &[6, 26, 46, 66],
    &[6, 26, 48, 70],
    &[6, 26, 50, 74],
    &[6, 30, 54, 78],
    &[6, 30, 56, 82],
    &[6, 30, 58, 86],
    &[6, 34, 62, 90],
    &[6, 28, 50, 72, 94],
    &[6, 26, 50, 74, 98],
    &[6, 30, 54, 78, 102],
    &[6, 28, 54, 80, 106],
    &[6, 32, 58, 84, 110],
    &[6, 30, 58, 86, 114],
    &[6, 34, 62, 90, 118],
    &[6, 26, 50, 74, 98, 122],
    &[6, 30, 54, 78, 102, 126],
    &[6, 26, 52, 78, 104, 130],
    &[6, 30, 56, 82, 108, 134],
    &[6, 34, 60, 86, 112, 138],
    &[6, 30, 58, 86, 114, 142],
    &[6, 34, 62, 90, 118, 146],
    &[6, 30, 54, 78, 102, 126, 150],
    &[6, 24, 50, 76, 102, 128, 154],
    &[6, 28, 54, 80, 106, 132, 158],
    &[6, 32, 58, 84, 110, 136, 162],
    &[6, 26, 54, 82, 110, 138, 166],
    &[6, 30, 58, 86, 114, 142, 170],
];

//}}}
//------------------------------------------------------------------------------
//{{{ Timing patterns

impl Canvas {
    /// Draws a line from (x1, y1) to (x2, y2), inclusively.
    ///
    /// The line must be either horizontal or vertical, i.e.
    /// `x1 == x2 || y1 == y2`. Additionally, the first coordinates must be less
    /// then the second ones.
    ///
    /// On even coordinates, `color_even` will be plotted; on odd coordinates,
    /// `color_odd` will be plotted instead. Thus the timing pattern can be
    /// drawn using this method.
    ///
    fn draw_line(&mut self, x1: i16, y1: i16, x2: i16, y2: i16,
                 color_even: Module, color_odd: Module) {
        debug_assert!(x1 == x2 || y1 == y2);

        if y1 == y2 {   // Horizontal line.
            for x in range_inclusive(x1, x2) {
                self.put(x, y1, if x % 2 == 0 { color_even } else { color_odd });
            }
        } else {        // Vertical line.
            for y in range_inclusive(y1, y2) {
                self.put(x1, y, if y % 2 == 0 { color_even } else { color_odd });
            }
        }
    }

    /// Draws the timing patterns.
    ///
    /// The timing patterns are checkboard-colored lines near the edge of the QR
    /// code symbol, to establish the fine-grained module coordinates when
    /// scanning.
    fn draw_timing_patterns(&mut self) {
        let width = self.width;
        let (y, x1, x2) = match self.version {
            MicroVersion(_) => (0, 8, width-1),
            Version(_) => (6, 8, width-9),
        };
        self.draw_line(x1, y, x2, y, Dark, Light);
        self.draw_line(y, x1, y, x2, Dark, Light);
    }
}

#[cfg(test)]
mod timing_pattern_tests {
    use canvas::Canvas;
    use types::{Version, MicroVersion, L};

    #[test]
    fn test_draw_timing_patterns_qr() {
        let mut c = Canvas::new(Version(1), L);
        c.draw_timing_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ????????#.#.#????????\n\
                    ?????????????????????\n\
                    ??????#??????????????\n\
                    ??????.??????????????\n\
                    ??????#??????????????\n\
                    ??????.??????????????\n\
                    ??????#??????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????");
    }

    #[test]
    fn test_draw_timing_patterns_micro_qr() {
        let mut c = Canvas::new(MicroVersion(1), L);
        c.draw_timing_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ????????#.#\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    #??????????\n\
                    .??????????\n\
                    #??????????");
    }
}

//}}}
//------------------------------------------------------------------------------
//{{{ Format info & Version info

impl Canvas {
    /// Draws a big-endian integer onto the canvas with the given coordinates.
    ///
    /// The 1 bits will be plotted with `on_color` and the 0 bits with
    /// `off_color`. The coordinates will be extracted from the `coords`
    /// iterator. It will start from the most significant bits first, so
    /// *trailing* zeros will be ignored.
    fn draw_number<N: Int>(&mut self, number: N,
                           on_color: Module, off_color: Module,
                           coords: &[(i16, i16)]) {
        let mut mask: N = !(!zero::<N>() >> 1);
        for &(x, y) in coords.iter() {
            let color = if (mask & number).is_zero() { off_color } else { on_color };
            self.put(x, y, color);
            mask = mask >> 1;
        }
    }

    /// Draws the format info patterns for an encoded number.
    fn draw_format_info_patterns_with_number(&mut self, format_info: u16) {
        match self.version {
            MicroVersion(_) => {
                self.draw_number(format_info, Dark, Light, FORMAT_INFO_COORDS_MICRO_QR);
            }
            Version(_) => {
                self.draw_number(format_info, Dark, Light, FORMAT_INFO_COORDS_QR_MAIN);
                self.draw_number(format_info, Dark, Light, FORMAT_INFO_COORDS_QR_SIDE);
                self.put(8, -8, Dark); // Dark module.
            }
        }
    }

    /// Reserves area to put in the format information.
    fn draw_reserved_format_info_patterns(&mut self) {
        self.draw_format_info_patterns_with_number(0);
    }

    /// Draws the version information patterns.
    fn draw_version_info_patterns(&mut self) {
        match self.version {
            MicroVersion(_) | Version(1..6) => { return; }
            Version(a) => {
                let version_info = VERSION_INFOS[(a - 7) as uint] << 14;
                self.draw_number(version_info, Dark, Light, VERSION_INFO_COORDS_BL);
                self.draw_number(version_info, Dark, Light, VERSION_INFO_COORDS_TR);
            }
        }
    }
}

#[cfg(test)]
mod draw_version_info_tests {
    use canvas::{Canvas, Light, Dark};
    use types::{MicroVersion, Version, L};

    #[test]
    fn test_draw_number() {
        let mut c = Canvas::new(MicroVersion(1), L);
        c.draw_number(0b10101101u8, Dark, Light, [(0,0), (0,-1), (-2,-2), (-2,0)]);
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #????????.?\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ???????????\n\
                    ?????????#?\n\
                    .??????????");
    }

    #[test]
    fn test_draw_version_info_1() {
        let mut c = Canvas::new(Version(1), L);
        c.draw_version_info_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????");
    }

    #[test]
    fn test_draw_version_info_7() {
        let mut c = Canvas::new(Version(7), L);
        c.draw_version_info_patterns();

        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ??????????????????????????????????..#????????\n\
                    ??????????????????????????????????.#.????????\n\
                    ??????????????????????????????????.#.????????\n\
                    ??????????????????????????????????.##????????\n\
                    ??????????????????????????????????###????????\n\
                    ??????????????????????????????????...????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ....#.???????????????????????????????????????\n\
                    .####.???????????????????????????????????????\n\
                    #..##.???????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????\n\
                    ?????????????????????????????????????????????");
    }

    #[test]
    fn test_draw_reserved_format_info_patterns_qr() {
        let mut c = Canvas::new(Version(1), L);
        c.draw_reserved_format_info_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ?????????????????????\n\
                    ????????.????????????\n\
                    ......?..????........\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ????????#????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????.????????????");
    }

    #[test]
    fn test_draw_reserved_format_info_patterns_micro_qr() {
        let mut c = Canvas::new(MicroVersion(1), L);
        c.draw_reserved_format_info_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ???????????\n\
                    ????????.??\n\
                    ????????.??\n\
                    ????????.??\n\
                    ????????.??\n\
                    ????????.??\n\
                    ????????.??\n\
                    ????????.??\n\
                    ?........??\n\
                    ???????????\n\
                    ???????????");
    }
}

static VERSION_INFO_COORDS_BL: [(i16, i16), ..18] = [
    (5, -9), (5, -10), (5, -11),
    (4, -9), (4, -10), (4, -11),
    (3, -9), (3, -10), (3, -11),
    (2, -9), (2, -10), (2, -11),
    (1, -9), (1, -10), (1, -11),
    (0, -9), (0, -10), (0, -11),
];

static VERSION_INFO_COORDS_TR: [(i16, i16), ..18] = [
    (-9, 5), (-10, 5), (-11, 5),
    (-9, 4), (-10, 4), (-11, 4),
    (-9, 3), (-10, 3), (-11, 3),
    (-9, 2), (-10, 2), (-11, 2),
    (-9, 1), (-10, 1), (-11, 1),
    (-9, 0), (-10, 0), (-11, 0),
];

static FORMAT_INFO_COORDS_QR_MAIN: [(i16, i16), ..15] = [
    (0, 8), (1, 8), (2, 8), (3, 8), (4, 8), (5, 8),
    (7, 8), (8, 8), (8, 7),
    (8, 5), (8, 4), (8, 3), (8, 2), (8, 1), (8, 0),
];

static FORMAT_INFO_COORDS_QR_SIDE: [(i16, i16), ..15] = [
    (8, -1), (8, -2), (8, -3), (8, -4), (8, -5), (8, -6), (8, -7),
    (-8, 8), (-7, 8), (-6, 8), (-5, 8), (-4, 8), (-3, 8), (-2, 8), (-1, 8),
];

static FORMAT_INFO_COORDS_MICRO_QR: [(i16, i16), ..15] = [
    (1, 8), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8),
    (8, 7), (8, 6), (8, 5), (8, 4), (8, 3), (8, 2), (8, 1),
];

static VERSION_INFOS: [u32, ..34] = [
    0x07c94, 0x085bc, 0x09a99, 0x0a4d3, 0x0bbf6, 0x0c762, 0x0d847, 0x0e60d,
    0x0f928, 0x10b78, 0x1145d, 0x12a17, 0x13532, 0x149a6, 0x15683, 0x168c9,
    0x177ec, 0x18ec4, 0x191e1, 0x1afab, 0x1b08e, 0x1cc1a, 0x1d33f, 0x1ed75,
    0x1f250, 0x209d5, 0x216f0, 0x228ba, 0x2379f, 0x24b0b, 0x2542e, 0x26a64,
    0x27541, 0x28c69,
];

//}}}
//------------------------------------------------------------------------------
//{{{ All functional patterns before data placement

impl Canvas {
    /// Draw all functional patterns, before data placement.
    ///
    /// All functional patterns (e.g. the finder pattern) *except* the format
    /// info pattern will be filled in. The format info pattern will be filled
    /// with light modules instead. Data bits can then put in the empty modules.
    /// with `.draw_data()`.
    pub fn draw_all_functional_patterns(&mut self) {
        self.draw_finder_patterns();
        self.draw_alignment_patterns();
        self.draw_reserved_format_info_patterns();
        self.draw_timing_patterns();
        self.draw_version_info_patterns();
    }
}

#[cfg(test)]
mod all_functional_patterns_tests {
    use canvas::Canvas;
    use types::{Version, MicroVersion, L};

    #[test]
    fn test_all_functional_patterns_qr() {
        let mut c = Canvas::new(Version(2), L);
        c.draw_all_functional_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######..????????.#######\n\
                    #.....#..????????.#.....#\n\
                    #.###.#..????????.#.###.#\n\
                    #.###.#..????????.#.###.#\n\
                    #.###.#..????????.#.###.#\n\
                    #.....#..????????.#.....#\n\
                    #######.#.#.#.#.#.#######\n\
                    .........????????........\n\
                    ......#..????????........\n\
                    ??????.??????????????????\n\
                    ??????#??????????????????\n\
                    ??????.??????????????????\n\
                    ??????#??????????????????\n\
                    ??????.??????????????????\n\
                    ??????#??????????????????\n\
                    ??????.??????????????????\n\
                    ??????#?????????#####????\n\
                    ........#???????#...#????\n\
                    #######..???????#.#.#????\n\
                    #.....#..???????#...#????\n\
                    #.###.#..???????#####????\n\
                    #.###.#..????????????????\n\
                    #.###.#..????????????????\n\
                    #.....#..????????????????\n\
                    #######..????????????????");
    }

    #[test]
    fn test_all_functional_patterns_micro_qr() {
        let mut c = Canvas::new(MicroVersion(1), L);
        c.draw_all_functional_patterns();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######.#.#\n\
                    #.....#..??\n\
                    #.###.#..??\n\
                    #.###.#..??\n\
                    #.###.#..??\n\
                    #.....#..??\n\
                    #######..??\n\
                    .........??\n\
                    #........??\n\
                    .??????????\n\
                    #??????????");
    }
}

//}}}
//------------------------------------------------------------------------------
//{{{ Data placement iterator

struct DataModuleIter {
    x: i16,
    y: i16,
    width: i16,
    timing_pattern_column: i16,
}

impl DataModuleIter {
    fn new(version: Version) -> DataModuleIter {
        let width = version.width();
        DataModuleIter {
            x: width - 1,
            y: width - 1,
            width: width,
            timing_pattern_column: match version {
                MicroVersion(_) => 0,
                Version(_) => 6,
            }
        }
    }
}

impl<'a> Iterator<(i16, i16)> for DataModuleIter {
    fn next(&mut self) -> Option<(i16, i16)> {
        let adjusted_ref_col = if self.x <= self.timing_pattern_column {
            self.x + 1
        } else {
            self.x
        };
        if adjusted_ref_col <= 0 {
            return None;
        }

        let res = (self.x, self.y);
        let column_type = (self.width - adjusted_ref_col) % 4;

        match column_type {
            2 if self.y > 0 => {
                self.y -= 1;
                self.x += 1;
            }
            0 if self.y < self.width - 1 => {
                self.y += 1;
                self.x += 1;
            }
            0 | 2 if self.x == self.timing_pattern_column + 1 => {
                self.x -= 2;
            }
            _ => {
                self.x -= 1;
            }
        }

        Some(res)
    }
}

#[cfg(test)]
mod data_iter_tests {
    use canvas::DataModuleIter;
    use types::{Version, MicroVersion};

    #[test]
    fn test_qr() {
        let res = DataModuleIter::new(Version(1)).collect::<Vec<(i16, i16)>>();
        assert_eq!(res, vec![
            (20, 20), (19, 20), (20, 19), (19, 19), (20, 18), (19, 18),
            (20, 17), (19, 17), (20, 16), (19, 16), (20, 15), (19, 15),
            (20, 14), (19, 14), (20, 13), (19, 13), (20, 12), (19, 12),
            (20, 11), (19, 11), (20, 10), (19, 10), (20, 9), (19, 9),
            (20, 8), (19, 8), (20, 7), (19, 7), (20, 6), (19, 6),
            (20, 5), (19, 5), (20, 4), (19, 4), (20, 3), (19, 3),
            (20, 2), (19, 2), (20, 1), (19, 1), (20, 0), (19, 0),

            (18, 0), (17, 0), (18, 1), (17, 1), (18, 2), (17, 2),
            (18, 3), (17, 3), (18, 4), (17, 4), (18, 5), (17, 5),
            (18, 6), (17, 6), (18, 7), (17, 7), (18, 8), (17, 8),
            (18, 9), (17, 9), (18, 10), (17, 10), (18, 11), (17, 11),
            (18, 12), (17, 12), (18, 13), (17, 13), (18, 14), (17, 14),
            (18, 15), (17, 15), (18, 16), (17, 16), (18, 17), (17, 17),
            (18, 18), (17, 18), (18, 19), (17, 19), (18, 20), (17, 20),

            (16, 20), (15, 20), (16, 19), (15, 19), (16, 18), (15, 18),
            (16, 17), (15, 17), (16, 16), (15, 16), (16, 15), (15, 15),
            (16, 14), (15, 14), (16, 13), (15, 13), (16, 12), (15, 12),
            (16, 11), (15, 11), (16, 10), (15, 10), (16, 9), (15, 9),
            (16, 8), (15, 8), (16, 7), (15, 7), (16, 6), (15, 6),
            (16, 5), (15, 5), (16, 4), (15, 4), (16, 3), (15, 3),
            (16, 2), (15, 2), (16, 1), (15, 1), (16, 0), (15, 0),

            (14, 0), (13, 0), (14, 1), (13, 1), (14, 2), (13, 2),
            (14, 3), (13, 3), (14, 4), (13, 4), (14, 5), (13, 5),
            (14, 6), (13, 6), (14, 7), (13, 7), (14, 8), (13, 8),
            (14, 9), (13, 9), (14, 10), (13, 10), (14, 11), (13, 11),
            (14, 12), (13, 12), (14, 13), (13, 13), (14, 14), (13, 14),
            (14, 15), (13, 15), (14, 16), (13, 16), (14, 17), (13, 17),
            (14, 18), (13, 18), (14, 19), (13, 19), (14, 20), (13, 20),

            (12, 20), (11, 20), (12, 19), (11, 19), (12, 18), (11, 18),
            (12, 17), (11, 17), (12, 16), (11, 16), (12, 15), (11, 15),
            (12, 14), (11, 14), (12, 13), (11, 13), (12, 12), (11, 12),
            (12, 11), (11, 11), (12, 10), (11, 10), (12, 9), (11, 9),
            (12, 8), (11, 8), (12, 7), (11, 7), (12, 6), (11, 6),
            (12, 5), (11, 5), (12, 4), (11, 4), (12, 3), (11, 3),
            (12, 2), (11, 2), (12, 1), (11, 1), (12, 0), (11, 0),

            (10, 0), (9, 0), (10, 1), (9, 1), (10, 2), (9, 2),
            (10, 3), (9, 3), (10, 4), (9, 4), (10, 5), (9, 5),
            (10, 6), (9, 6), (10, 7), (9, 7), (10, 8), (9, 8),
            (10, 9), (9, 9), (10, 10), (9, 10), (10, 11), (9, 11),
            (10, 12), (9, 12), (10, 13), (9, 13), (10, 14), (9, 14),
            (10, 15), (9, 15), (10, 16), (9, 16), (10, 17), (9, 17),
            (10, 18), (9, 18), (10, 19), (9, 19), (10, 20), (9, 20),

            (8, 20), (7, 20), (8, 19), (7, 19), (8, 18), (7, 18),
            (8, 17), (7, 17), (8, 16), (7, 16), (8, 15), (7, 15),
            (8, 14), (7, 14), (8, 13), (7, 13), (8, 12), (7, 12),
            (8, 11), (7, 11), (8, 10), (7, 10), (8, 9), (7, 9),
            (8, 8), (7, 8), (8, 7), (7, 7), (8, 6), (7, 6),
            (8, 5), (7, 5), (8, 4), (7, 4), (8, 3), (7, 3),
            (8, 2), (7, 2), (8, 1), (7, 1), (8, 0), (7, 0),

            (5, 0), (4, 0), (5, 1), (4, 1), (5, 2), (4, 2),
            (5, 3), (4, 3), (5, 4), (4, 4), (5, 5), (4, 5),
            (5, 6), (4, 6), (5, 7), (4, 7), (5, 8), (4, 8),
            (5, 9), (4, 9), (5, 10), (4, 10), (5, 11), (4, 11),
            (5, 12), (4, 12), (5, 13), (4, 13), (5, 14), (4, 14),
            (5, 15), (4, 15), (5, 16), (4, 16), (5, 17), (4, 17),
            (5, 18), (4, 18), (5, 19), (4, 19), (5, 20), (4, 20),

            (3, 20), (2, 20), (3, 19), (2, 19), (3, 18), (2, 18),
            (3, 17), (2, 17), (3, 16), (2, 16), (3, 15), (2, 15),
            (3, 14), (2, 14), (3, 13), (2, 13), (3, 12), (2, 12),
            (3, 11), (2, 11), (3, 10), (2, 10), (3, 9), (2, 9),
            (3, 8), (2, 8), (3, 7), (2, 7), (3, 6), (2, 6),
            (3, 5), (2, 5), (3, 4), (2, 4), (3, 3), (2, 3),
            (3, 2), (2, 2), (3, 1), (2, 1), (3, 0), (2, 0),

            (1, 0), (0, 0), (1, 1), (0, 1), (1, 2), (0, 2),
            (1, 3), (0, 3), (1, 4), (0, 4), (1, 5), (0, 5),
            (1, 6), (0, 6), (1, 7), (0, 7), (1, 8), (0, 8),
            (1, 9), (0, 9), (1, 10), (0, 10), (1, 11), (0, 11),
            (1, 12), (0, 12), (1, 13), (0, 13), (1, 14), (0, 14),
            (1, 15), (0, 15), (1, 16), (0, 16), (1, 17), (0, 17),
            (1, 18), (0, 18), (1, 19), (0, 19), (1, 20), (0, 20),
        ]);
    }

    #[test]
    fn test_micro_qr() {
        let res = DataModuleIter::new(MicroVersion(1)).collect::<Vec<(i16, i16)>>();
        assert_eq!(res, vec![
            (10, 10), (9, 10), (10, 9), (9, 9), (10, 8), (9, 8),
            (10, 7), (9, 7), (10, 6), (9, 6), (10, 5), (9, 5),
            (10, 4), (9, 4), (10, 3), (9, 3), (10, 2), (9, 2),
            (10, 1), (9, 1), (10, 0), (9, 0),

            (8, 0), (7, 0), (8, 1), (7, 1), (8, 2), (7, 2),
            (8, 3), (7, 3), (8, 4), (7, 4), (8, 5), (7, 5),
            (8, 6), (7, 6), (8, 7), (7, 7), (8, 8), (7, 8),
            (8, 9), (7, 9), (8, 10), (7, 10),

            (6, 10), (5, 10), (6, 9), (5, 9), (6, 8), (5, 8),
            (6, 7), (5, 7), (6, 6), (5, 6), (6, 5), (5, 5),
            (6, 4), (5, 4), (6, 3), (5, 3), (6, 2), (5, 2),
            (6, 1), (5, 1), (6, 0), (5, 0),

            (4, 0), (3, 0), (4, 1), (3, 1), (4, 2), (3, 2),
            (4, 3), (3, 3), (4, 4), (3, 4), (4, 5), (3, 5),
            (4, 6), (3, 6), (4, 7), (3, 7), (4, 8), (3, 8),
            (4, 9), (3, 9), (4, 10), (3, 10),

            (2, 10), (1, 10), (2, 9), (1, 9), (2, 8), (1, 8),
            (2, 7), (1, 7), (2, 6), (1, 6), (2, 5), (1, 5),
            (2, 4), (1, 4), (2, 3), (1, 3), (2, 2), (1, 2),
            (2, 1), (1, 1), (2, 0), (1, 0),
        ]);
    }

    #[test]
    fn test_micro_qr_2() {
        let res = DataModuleIter::new(MicroVersion(2)).collect::<Vec<(i16, i16)>>();
        assert_eq!(res, vec![
            (12, 12), (11, 12), (12, 11), (11, 11), (12, 10), (11, 10),
            (12, 9), (11, 9), (12, 8), (11, 8), (12, 7), (11, 7),
            (12, 6), (11, 6), (12, 5), (11, 5), (12, 4), (11, 4),
            (12, 3), (11, 3), (12, 2), (11, 2), (12, 1), (11, 1),
            (12, 0), (11, 0),

            (10, 0), (9, 0), (10, 1), (9, 1), (10, 2), (9, 2),
            (10, 3), (9, 3), (10, 4), (9, 4), (10, 5), (9, 5),
            (10, 6), (9, 6), (10, 7), (9, 7), (10, 8), (9, 8),
            (10, 9), (9, 9), (10, 10), (9, 10), (10, 11), (9, 11),
            (10, 12), (9, 12),

            (8, 12), (7, 12), (8, 11), (7, 11), (8, 10), (7, 10),
            (8, 9), (7, 9), (8, 8), (7, 8), (8, 7), (7, 7),
            (8, 6), (7, 6), (8, 5), (7, 5), (8, 4), (7, 4),
            (8, 3), (7, 3), (8, 2), (7, 2), (8, 1), (7, 1),
            (8, 0), (7, 0),

            (6, 0), (5, 0), (6, 1), (5, 1), (6, 2), (5, 2),
            (6, 3), (5, 3), (6, 4), (5, 4), (6, 5), (5, 5),
            (6, 6), (5, 6), (6, 7), (5, 7), (6, 8), (5, 8),
            (6, 9), (5, 9), (6, 10), (5, 10), (6, 11), (5, 11),
            (6, 12), (5, 12),

            (4, 12), (3, 12), (4, 11), (3, 11), (4, 10), (3, 10),
            (4, 9), (3, 9), (4, 8), (3, 8), (4, 7), (3, 7),
            (4, 6), (3, 6), (4, 5), (3, 5), (4, 4), (3, 4),
            (4, 3), (3, 3), (4, 2), (3, 2), (4, 1), (3, 1),
            (4, 0), (3, 0),

            (2, 0), (1, 0), (2, 1), (1, 1), (2, 2), (1, 2),
            (2, 3), (1, 3), (2, 4), (1, 4), (2, 5), (1, 5),
            (2, 6), (1, 6), (2, 7), (1, 7), (2, 8), (1, 8),
            (2, 9), (1, 9), (2, 10), (1, 10), (2, 11), (1, 11),
            (2, 12), (1, 12),
        ]);
    }
}

//}}}
//------------------------------------------------------------------------------
//{{{ Data placement

fn draw_codewords<'a, I: Iterator<&'a mut Module>>(codewords: &[u8],
                                                   is_half_codeword_at_end: bool,
                                                   modules: &mut I) {
    let length = codewords.len();
    let last_word = if is_half_codeword_at_end { length-1 } else { length };
    for (i, b) in codewords.iter().enumerate() {
        let bits_end = if i == last_word { 4 } else { 0 };
        for j in range_inclusive(bits_end, 7u).rev() {
            let color = if (*b & (1 << j)) != 0 { DarkUnmasked } else { LightUnmasked };
            match modules.next() {
                Some(module) => { *module = color; }
                None => { return; }
            }
        }
    }
}

impl Canvas {
    /// Draws the encoded data and error correction codes to the empty modules.
    pub fn draw_data(&mut self, data: &[u8], ec: &[u8]) {
        let is_half_codeword_at_end = match (self.version, self.ec_level) {
            (MicroVersion(1), L) | (MicroVersion(3), M) => true,
            _ => false,
        };

        let mut coords = DataModuleIter::new(self.version)
                                       .filter_map(|(x, y)| {
                                            let r = self.get_mut(x, y);
                                            if *r != Empty { None } else { Some(r) }
                                       });
        draw_codewords(data, is_half_codeword_at_end, &mut coords);
        draw_codewords(ec, false, &mut coords);
    }
}

#[cfg(test)]
mod draw_codewords_test {
    use canvas::Canvas;
    use types::{Version, MicroVersion, L};

    #[test]
    fn test_micro_qr_1() {
        let mut c = Canvas::new(MicroVersion(1), L);
        c.draw_all_functional_patterns();
        c.draw_data(b"\x6e\x5d\xe2", b"\x2b\x63");
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######.#.#\n\
                    #.....#..-*\n\
                    #.###.#..**\n\
                    #.###.#..*-\n\
                    #.###.#..**\n\
                    #.....#..*-\n\
                    #######..*-\n\
                    .........-*\n\
                    #........**\n\
                    .***-**---*\n\
                    #---*-*-**-");
    }

    #[test]
    fn test_qr_2() {
        let mut c = Canvas::new(Version(2), L);
        c.draw_all_functional_patterns();
        c.draw_data(b"\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$\x92I$", b"");
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######..--*---*-.#######\n\
                    #.....#..-*-*-*-*.#.....#\n\
                    #.###.#..*---*---.#.###.#\n\
                    #.###.#..--*---*-.#.###.#\n\
                    #.###.#..-*-*-*-*.#.###.#\n\
                    #.....#..*---*---.#.....#\n\
                    #######.#.#.#.#.#.#######\n\
                    .........--*---*-........\n\
                    ......#..-*-*-*-*........\n\
                    --*-*-.-**---*---*--**--*\n\
                    -*-*--#----*---*---------\n\
                    *----*.*--*-*-*-*-**--**-\n\
                    --*-*-#-**---*---*--**--*\n\
                    -*-*--.----*---*---------\n\
                    *----*#*--*-*-*-*-**--**-\n\
                    --*-*-.-**---*---*--**--*\n\
                    -*-*--#----*---*#####----\n\
                    ........#-*-*-*-#...#-**-\n\
                    #######..*---*--#.#.#*--*\n\
                    #.....#..--*---*#...#----\n\
                    #.###.#..-*-*-*-#####-**-\n\
                    #.###.#..*---*--*----*--*\n\
                    #.###.#..--*------**-----\n\
                    #.....#..-*-*-**-*--*-**-\n\
                    #######..*---*--*----*--*");
    }
}
//}}}
//------------------------------------------------------------------------------
//{{{ Masking

/// The mask patterns. Since QR code and Micro QR code do not use the same
/// pattern number, we name them according to their shape instead of the number.
#[deriving(Show)]
pub enum MaskPattern {
    /// QR code pattern 000: `(x + y) % 2 == 0`.
    Checkerboard = 0b000,

    /// QR code pattern 001: `y % 2 == 0`.
    HorizontalLines = 0b001,

    /// QR code pattern 010: `x % 3 == 0`.
    VerticalLines = 0b010,

    /// QR code pattern 011: `(x + y) % 3 == 0`.
    DiagonalLines = 0b011,

    /// QR code pattern 100: `((x/3) + (y/2)) % 2 == 0`.
    LargeCheckerboard = 0b100,

    /// QR code pattern 101: `(x*y)%2 + (x*y)%3 == 0`.
    Fields = 0b101,

    /// QR code pattern 110: `((x*y)%2 + (x*y)%3) % 2 == 0`.
    Diamonds = 0b110,

    /// QR code pattern 111: `((x+y)%2 + (x*y)%3) % 2 == 0`.
    Meadow = 0b111,
}

mod mask_functions {
    pub fn checkerboard(x: i16, y: i16) -> bool { (x + y) % 2 == 0 }
    pub fn horizontal_lines(_: i16, y: i16) -> bool { y % 2 == 0 }
    pub fn vertical_lines(x: i16, _: i16) -> bool { x % 3 == 0 }
    pub fn diagonal_lines(x: i16, y: i16) -> bool { (x + y) % 3 == 0 }
    pub fn large_checkerboard(x: i16, y: i16) -> bool { ((y/2) + (x/3)) % 2 == 0 }
    pub fn fields(x: i16, y: i16) -> bool { (x*y)%2 + (x*y)%3 == 0 }
    pub fn diamonds(x: i16, y: i16) -> bool { ((x*y)%2 + (x*y)%3) % 2 == 0 }
    pub fn meadow(x: i16, y: i16) -> bool { ((x+y)%2 + (x*y)%3) % 2 == 0 }
}

fn get_mask_function(pattern: MaskPattern) -> fn(i16, i16) -> bool {
    match pattern {
        Checkerboard => mask_functions::checkerboard,
        HorizontalLines => mask_functions::horizontal_lines,
        VerticalLines => mask_functions::vertical_lines,
        DiagonalLines => mask_functions::diagonal_lines,
        LargeCheckerboard => mask_functions::large_checkerboard,
        Fields => mask_functions::fields,
        Diamonds => mask_functions::diamonds,
        Meadow => mask_functions::meadow,
    }
}

impl Canvas {
    /// Applies a mask to the canvas. This method will also draw the format info
    /// patterns.
    pub fn apply_mask(&mut self, pattern: MaskPattern) {
        let mask_fn = get_mask_function(pattern);
        for x in range(0, self.width) {
            for y in range(0, self.width) {
                let module = self.get_mut(x, y);
                *module = module.mask(mask_fn(x, y));
            }
        }

        self.draw_format_info_patterns(pattern);
    }

    /// Draws the format information to encode the error correction level and
    /// mask pattern.
    ///
    /// If the error correction level or mask pattern is not supported in the
    /// current QR code version, this method will fail.
    fn draw_format_info_patterns(&mut self, pattern: MaskPattern) {
        let format_number = match self.version {
            Version(_) => {
                let simple_format_number = ((self.ec_level as uint) ^ 1) << 3 | (pattern as uint);
                FORMAT_INFOS_QR[simple_format_number]
            }
            MicroVersion(a) => {
                let micro_pattern_number = match pattern {
                    HorizontalLines => 0b00,
                    LargeCheckerboard => 0b01,
                    Diamonds => 0b10,
                    Meadow => 0b11,
                    _ => fail!("Unsupported mask pattern in Micro QR code"),
                };
                let symbol_number = match (a, self.ec_level) {
                    (1, L) => 0b000,
                    (2, L) => 0b001,
                    (2, M) => 0b010,
                    (3, L) => 0b011,
                    (3, M) => 0b100,
                    (4, L) => 0b101,
                    (4, M) => 0b110,
                    (4, Q) => 0b111,
                    _ => fail!("Unsupported version/ec_level combination in Micro QR code"),
                };
                let simple_format_number = symbol_number << 2 | micro_pattern_number;
                FORMAT_INFOS_MICRO_QR[simple_format_number]
            }
        };
        self.draw_format_info_patterns_with_number(format_number << 1);
    }
}

#[cfg(test)]
mod mask_tests {
    use canvas::{Canvas, Checkerboard, LargeCheckerboard};
    use types::{Version, MicroVersion, L};

    #[test]
    fn test_apply_mask_qr() {
        let mut c = Canvas::new(Version(1), L);
        c.draw_all_functional_patterns();
        c.apply_mask(Checkerboard);

        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######...#.#.#######\n\
                    #.....#..#.#..#.....#\n\
                    #.###.#.#.#.#.#.###.#\n\
                    #.###.#..#.#..#.###.#\n\
                    #.###.#...#.#.#.###.#\n\
                    #.....#..#.#..#.....#\n\
                    #######.#.#.#.#######\n\
                    ........##.#.........\n\
                    ###.#####.#.###...#..\n\
                    .#.#.#.#.#.#.#.#.#.#.\n\
                    #.#.#.#.#.#.#.#.#.#.#\n\
                    .#.#.#.#.#.#.#.#.#.#.\n\
                    #.#.#.#.#.#.#.#.#.#.#\n\
                    ........##.#.#.#.#.#.\n\
                    #######.#.#.#.#.#.#.#\n\
                    #.....#.##.#.#.#.#.#.\n\
                    #.###.#.#.#.#.#.#.#.#\n\
                    #.###.#..#.#.#.#.#.#.\n\
                    #.###.#.#.#.#.#.#.#.#\n\
                    #.....#.##.#.#.#.#.#.\n\
                    #######.#.#.#.#.#.#.#");
    }

    #[test]
    fn test_draw_format_info_patterns_qr() {
        let mut c = Canvas::new(Version(1), L);
        c.draw_format_info_patterns(LargeCheckerboard);
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ????????#????????????\n\
                    ????????#????????????\n\
                    ????????#????????????\n\
                    ????????#????????????\n\
                    ????????.????????????\n\
                    ????????#????????????\n\
                    ?????????????????????\n\
                    ????????.????????????\n\
                    ##..##?..????..#.####\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ????????#????????????\n\
                    ????????.????????????\n\
                    ????????#????????????\n\
                    ????????#????????????\n\
                    ????????.????????????\n\
                    ????????.????????????\n\
                    ????????#????????????\n\
                    ????????#????????????");
    }

    #[test]
    fn test_draw_format_info_patterns_micro_qr() {
        let mut c = Canvas::new(MicroVersion(2), L);
        c.draw_format_info_patterns(LargeCheckerboard);
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ?????????????\n\
                    ????????#????\n\
                    ????????.????\n\
                    ????????.????\n\
                    ????????#????\n\
                    ????????#????\n\
                    ????????.????\n\
                    ????????.????\n\
                    ?#.#....#????\n\
                    ?????????????\n\
                    ?????????????\n\
                    ?????????????\n\
                    ?????????????");
    }
}

static FORMAT_INFOS_QR: [u16, ..32] = [
    0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0,
    0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976,
    0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b,
    0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed,
];

static FORMAT_INFOS_MICRO_QR: [u16, ..32] = [
    0x4445, 0x4172, 0x4e2b, 0x4b1c, 0x55ae, 0x5099, 0x5fc0, 0x5af7,
    0x6793, 0x62a4, 0x6dfd, 0x68ca, 0x7678, 0x734f, 0x7c16, 0x7921,
    0x06de, 0x03e9, 0x0cb0, 0x0987, 0x1735, 0x1202, 0x1d5b, 0x186c,
    0x2508, 0x203f, 0x2f66, 0x2a51, 0x34e3, 0x31d4, 0x3e8d, 0x3bba,
];

//}}}
//------------------------------------------------------------------------------
//{{{ Penalty score

impl Canvas {
    /// Compute the penalty score for having too many adjacent modules with the
    /// same color.
    ///
    /// Every 5+N adjacent modules in the same column/row having the same color
    /// will contribute 3+N points.
    fn compute_adjacent_penalty_score(&self, is_horizontal: bool) -> u16 {
        let mut total_score = 0;

        for i in range(0, self.width) {
            let map_fn = if is_horizontal {
                |j| self.get(j, i)
            } else {
                |j| self.get(i, j)
            };

            let mut colors = range(0, self.width).map(map_fn).chain(Some(Empty).move_iter());

            let mut last_color = Empty;
            let mut consecutive_len = 1u16;

            for color in colors {
                if color == last_color {
                    consecutive_len += 1;
                } else {
                    last_color = color;
                    if consecutive_len >= 5 {
                        total_score += consecutive_len - 2;
                    }
                    consecutive_len = 1;
                }
            }
        }

        total_score
    }

    /// Compute the penalty score for having too many rectangles with the same
    /// color.
    ///
    /// Every 2Ã—2 blocks (with overlapping counted) having the same color will
    /// contribute 3 points.
    fn compute_block_penalty_score(&self) -> u16 {
        let mut total_score = 0;

        for i in range(0, self.width-1) {
            for j in range(0, self.width-1) {
                let this = self.get(i, j);
                let right = self.get(i+1, j);
                let bottom = self.get(i, j+1);
                let bottom_right = self.get(i+1, j+1);
                if this == right && right == bottom && bottom == bottom_right {
                    total_score += 3;
                }
            }
        }

        total_score
    }

    /// Compute the penalty score for having a pattern similar to the finder
    /// pattern in the wrong place.
    ///
    /// Every pattern that looks like `#.###.#....` in any orientation will add
    /// 40 points.
    fn compute_finder_penalty_score(&self, is_horizontal: bool) -> u16 {
        static PATTERN: [Module, ..7] = [Dark, Light, Dark, Dark, Dark, Light, Dark];

        let mut total_score = 0;

        for i in range(0, self.width) {
            for j in range(0, self.width-6) {
                let get = if is_horizontal {
                    |k: i16| self.get(k, i)
                } else {
                    |k: i16| self.get(i, k)
                };

                if !equals(range(j, j+7).map(|k| get(k)), PATTERN.iter().map(|m| *m)) {
                    continue;
                }

                let check = |k| { 0 <= k && k < self.width && get(k).is_dark() };
                if !range(j-4, j).any(|k| check(k)) || !range(j+7, j+11).any(|k| check(k)) {
                    total_score += 40;
                }
            }
        }

        total_score - 360
    }

    /// Compute the penalty score for having an unbalanced dark/light ratio.
    ///
    /// The score is given linearly by the deviation from a 50% ratio of dark
    /// modules. The highest possible score is 100.
    ///
    /// Note that this algorithm differs slightly from the standard we do not
    /// round the result every 5%, but the difference should be negligible and
    /// should not affect which mask is chosen.
    fn compute_balance_penalty_score(&self) -> u16 {
        let dark_modules = self.modules.iter().filter(|m| m.is_dark()).count();
        let total_modules = self.modules.len();
        let ratio = dark_modules * 200 / total_modules;
        (if ratio >= 100 {
            ratio - 100
        } else {
            100 - ratio
        }) as u16
    }

    /// Compute the penalty score for having too many light modules on the sides.
    ///
    /// This penalty score is exclusive to Micro QR code.
    ///
    /// Note that the standard gives the formula for *efficiency* score, which
    /// has the inverse meaning of this method, but it is very easy to convert
    /// between the two (this score is (16Ã—width âˆ’ standard-score)).
    fn compute_light_side_penalty_score(&self) -> u16 {
        let h = range(1, self.width).filter(|j| !self.get(*j, -1).is_dark()).count();
        let v = range(1, self.width).filter(|j| !self.get(-1, *j).is_dark()).count();

        (h + v + 15 * max(h, v)) as u16
    }

    /// Compute the total penalty scores. A QR code having higher points is less
    /// desirable.
    fn compute_total_penalty_scores(&self) -> u16 {

        match self.version {
            Version(_) => {
                let s1a = self.compute_adjacent_penalty_score(true);
                let s1b = self.compute_adjacent_penalty_score(false);
                let s2 = self.compute_block_penalty_score();
                let s3a = self.compute_finder_penalty_score(true);
                let s3b = self.compute_finder_penalty_score(false);
                let s4 = self.compute_balance_penalty_score();
                s1a + s1b + s2 + s3a + s3b + s4
            }
            MicroVersion(_) => self.compute_light_side_penalty_score(),
        }
    }
}

#[cfg(test)]
mod penalty_tests {
    use canvas::{Canvas, Checkerboard, Module, Light, Dark};
    use types::{Version, MicroVersion, Q};

    fn create_test_canvas() -> Canvas {
        let mut c = Canvas::new(Version(1), Q);
        c.draw_all_functional_patterns();
        c.draw_data(b"\x20\x5b\x0b\x78\xd1\x72\xdc\x4d\x43\x40\xec\x11\x00",
                    b"\xa8\x48\x16\x52\xd9\x36\x9c\x00\x2e\x0f\xb4\x7a\x10");
        c.apply_mask(Checkerboard);
        c
    }

    #[test]
    fn check_penalty_canvas() {
        let c = create_test_canvas();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######.##....#######\n\
                    #.....#.#..#..#.....#\n\
                    #.###.#.#..##.#.###.#\n\
                    #.###.#.#.....#.###.#\n\
                    #.###.#.#.#...#.###.#\n\
                    #.....#...#...#.....#\n\
                    #######.#.#.#.#######\n\
                    ........#............\n\
                    .##.#.##....#.#.#####\n\
                    .#......####....#...#\n\
                    ..##.###.##...#.##...\n\
                    .##.##.#..##.#.#.###.\n\
                    #...#.#.#.###.###.#.#\n\
                    ........##.#..#...#.#\n\
                    #######.#.#....#.##..\n\
                    #.....#..#.##.##.#...\n\
                    #.###.#.#.#...#######\n\
                    #.###.#..#.#.#.#...#.\n\
                    #.###.#.#...####.#..#\n\
                    #.....#.#.##.#...#.##\n\
                    #######.....####....#");
    }

    #[test]
    fn test_penalty_score_adjacent() {
        let c = create_test_canvas();
        assert_eq!(c.compute_adjacent_penalty_score(true), 88);
        assert_eq!(c.compute_adjacent_penalty_score(false), 92);
    }

    #[test]
    fn test_penalty_score_block() {
        let c = create_test_canvas();
        assert_eq!(c.compute_block_penalty_score(), 90);
    }

    #[test]
    fn test_penalty_score_finder() {
        let c = create_test_canvas();
        assert_eq!(c.compute_finder_penalty_score(true), 0);
        assert_eq!(c.compute_finder_penalty_score(false), 40);
    }

    #[test]
    fn test_penalty_score_balance() {
        let c = create_test_canvas();
        assert_eq!(c.compute_balance_penalty_score(), 2);
    }

    #[test]
    fn test_penalty_score_light_sides() {
        static HORIZONTAL_SIDE: [Module, ..17] = [
            Dark, Light, Light, Dark, Dark, Dark, Light, Light,
            Dark, Light, Dark, Light, Light, Dark, Light, Light, Light
        ];
        static VERTICAL_SIDE: [Module, ..17] = [
            Dark, Dark, Dark, Light, Light, Dark, Dark, Light,
            Dark, Light, Dark, Light, Dark, Light, Light, Dark, Light
        ];

        let mut c = Canvas::new(MicroVersion(4), Q);
        for i in range(0, 17) {
            c.put(i, -1, HORIZONTAL_SIDE[i as uint]);
            c.put(-1, i, VERTICAL_SIDE[i as uint]);
        }

        assert_eq!(c.compute_light_side_penalty_score(), 168);
    }
}

//}}}
//------------------------------------------------------------------------------
//{{{ Select mask with lowest penalty score

static ALL_PATTERNS_QR: [MaskPattern, ..8] = [
    Checkerboard, HorizontalLines, VerticalLines, DiagonalLines,
    LargeCheckerboard, Fields, Diamonds, Meadow
];

static ALL_PATTERNS_MICRO_QR: [MaskPattern, ..4] = [
    HorizontalLines, LargeCheckerboard, Diamonds, Meadow
];

impl Canvas {
    /// Construct a new canvas and apply the best masking that gives the lowest
    /// penalty score.
    pub fn apply_best_mask(&self) -> Canvas {
        let patterns = match self.version {
            Version(_) => ALL_PATTERNS_QR.iter(),
            MicroVersion(_) => ALL_PATTERNS_MICRO_QR.iter(),
        };

        patterns.map(|ptn| {
            let mut c = self.clone();
            c.apply_mask(*ptn);
            c
        }).min_by(|c| c.compute_total_penalty_scores()).unwrap()
    }

    /// Convert the modules into a vector of booleans.
    pub fn to_bools(&self) -> Vec<bool> {
        self.modules.iter().map(|m| m.is_dark()).collect()
    }
}

//}}}
//------------------------------------------------------------------------------

/*

static ALL_PATTERNS: [MaskPattern, ..8] = [Pattern0, Pattern1, Pattern2, Pattern3, Pattern4, Pattern5, Pattern6, Pattern7];


fn apply_mask(canvas: &mut Canvas, ec_level: ErrorCorrectionLevel, pattern: MaskPattern) {
    draw_format_info_patterns(canvas, ec_level, pattern);

    let width = canvas.width();
    for y in range(0, width) {
        for x in range(0, width) {
            if should_mask(pattern, x, y) {
                let mut color = canvas.index_mut(&(x, y));
                *color = match *color {
                    DataWhite => DataBlack,
                    DataBlack => DataWhite,
                    other => other,
                };
            }
        }
    }
}

fn is_black(color: ModuleState) -> bool {
    match color {
        Black | DataBlack => true,
        Empty | White | DataWhite => false,
    }
}

fn evaluate_adjacent_penalty(canvas: &Canvas, is_horizontal: bool) -> uint {
    let mut score = 0u;
    let width = canvas.width();

    let mut prev_is_black = false;
    let mut consec_length = 1u;
    for x in range(0, width) {
        for y in range(0, width) {
            let coords = if is_horizontal { (y, x) } else { (x, y) };
            let cur_is_black = is_black((*canvas)[coords]);
            if y != 0 && prev_is_black == cur_is_black {
                consec_length += 1;
            } else {
                if consec_length >= 5 {
                    score += consec_length - 2;
                }
                consec_length = 1;
            }
            prev_is_black = cur_is_black;
        }
    }

    if consec_length >= 5 {
        score += consec_length - 2;
    }

    score
}

fn evaluate_block_penalty(canvas: &Canvas) -> uint {
    let mut score = 0u;
    let width = canvas.width();

    for x in range(0, width-1) {
        for y in range(0, width-1) {
            let color0 = is_black((*canvas)[(x, y)]);
            let color1 = is_black((*canvas)[(x+1, y)]);
            let color2 = is_black((*canvas)[(x, y+1)]);
            let color3 = is_black((*canvas)[(x+1, y+1)]);
            if color0 == color1 && color1 == color2 && color2 == color3 {
                score += 3;
            }
        }
    }

    score
}

fn evaluate_finder_penalty(canvas: &Canvas, is_horizontal: bool) -> uint {
    use std::iter::order::eq;

    let mut score = 0u;
    let width = canvas.width();

    for x in range(0, width) {
        for y in range(0, width-6) {
            let colors = range(y, y+7)
                            .map(|r| if is_horizontal { (r, x) } else { (x, r) })
                            .map(|coords| is_black((*canvas)[coords]));
            if eq(colors, [true, false, true, true, true, false, true].iter().map(|&b| b)) {
                score += 40;
            }
        }
    }

    score
}

fn evaluate_proportion_penalty(canvas: &Canvas) -> uint {
    let black_modules = canvas.modules.iter().filter(|&&m| is_black(m)).count();
    let width = canvas.width;
    let total_modules = width * width;
    let ratio = black_modules * 200 / total_modules;
    if ratio >= 100 { ratio - 100 } else { 100 - ratio }
}

fn apply_best_mask(canvas: &Canvas, ec_level: ErrorCorrectionLevel) -> Canvas {
    ALL_PATTERNS.iter().map(|&pattern| {
        let mut canvas_copy = canvas.clone();
        apply_mask(&mut canvas_copy, ec_level, pattern);
        canvas_copy
    }).min_by(|c| {
        use std::io::stdio::stdout;
        let s1 = evaluate_adjacent_penalty(c, true);
        let s2 = evaluate_adjacent_penalty(c, false);
        let s3 = evaluate_block_penalty(c);
        let s4 = evaluate_finder_penalty(c, true);
        let s5 = evaluate_finder_penalty(c, false);
        let s6 = evaluate_proportion_penalty(c);
        stdout().write_line(format!("{} + {} + {} + {} + {} + {}", s1, s2, s3, s4, s5, s6).as_slice());
        s1 + s2 + s3 + s4 + s5 + s6
    }).unwrap()
}


#[cfg(test)]
mod tests {
    use collections::{bitv, Bitv};
    use canvas::{Canvas, Empty, Black, White, DataBlack, DataWhite,
                 draw_finder_patterns, draw_alignment_patterns,
                 draw_timing_patterns, draw_version_info_patterns,
                 draw_format_info_patterns, Pattern4, Pattern0, apply_mask,
                 draw_all_functional_patterns, evaluate_adjacent_penalty,
                 evaluate_block_penalty, evaluate_finder_penalty,
                 evaluate_proportion_penalty, apply_best_mask};
    use ec::{L, Q};

    #[test]
    fn test_draw_format_info_patterns() {
        let mut c = Canvas::new(1);
        draw_format_info_patterns(&mut c, L, Pattern4);
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ????????#????????????\n\
                    ????????#????????????\n\
                    ????????#????????????\n\
                    ????????#????????????\n\
                    ???????? ????????????\n\
                    ????????#????????????\n\
                    ?????????????????????\n\
                    ???????? ????????????\n\
                    ##  ##?  ????  # ####\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ?????????????????????\n\
                    ???????? ????????????\n\
                    ????????#????????????\n\
                    ????????#????????????\n\
                    ???????? ????????????\n\
                    ???????? ????????????\n\
                    ????????#????????????\n\
                    ????????#????????????");
    }

    #[test]
    fn test_draw_all_functional_patterns() {
        let mut c = Canvas::new(2);
        draw_all_functional_patterns(&mut c);
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######  ???????? #######\n\
                    #     #  ???????? #     #\n\
                    # ### #  ???????? # ### #\n\
                    # ### #  ???????? # ### #\n\
                    # ### #  ???????? # ### #\n\
                    #     #  ???????? #     #\n\
                    ####### # # # # # #######\n\
                 \x20        ????????        \n\
                 \x20     #  ????????        \n\
                    ?????? ??????????????????\n\
                    ??????#??????????????????\n\
                    ?????? ??????????????????\n\
                    ??????#??????????????????\n\
                    ?????? ??????????????????\n\
                    ??????#??????????????????\n\
                    ?????? ??????????????????\n\
                    ??????#?????????#####????\n\
                 \x20       #???????#   #????\n\
                    #######  ???????# # #????\n\
                    #     #  ???????#   #????\n\
                    # ### #  ???????#####????\n\
                    # ### #  ????????????????\n\
                    # ### #  ????????????????\n\
                    #     #  ????????????????\n\
                    #######  ????????????????");
    }

    #[test]
    fn test_empty_modules_increase() {
        use canvas::DataModuleIter;

        let res: Vec<uint> = DataModuleIter::new(17).collect();

        assert_eq!(res, vec![
            0,17,1,18,2,19,3,20,4,21,5,22,6,23,7,24,8,25,9,26,10,27,11,28,12,29,
            13,30,14,31,15,32,16,33,50,67,49,66,48,65,47,64,46,63,45,62,44,61,
            43,60,42,59,41,58,40,57,39,56,38,55,37,54,36,53,35,52,34,51,68,85,
            69,86,70,87,71,88,72,89,73,90,74,91,75,92,76,93,77,94,78,95,79,96,
            80,97,81,98,82,99,83,100,84,101,118,135,117,134,116,133,115,132,114,
            131,113,130,112,129,111,128,110,127,109,126,108,125,107,124,106,123,
            105,122,104,121,103,120,102,119,136,153,137,154,138,155,139,156,140,
            157,141,158,142,159,143,160,144,161,145,162,146,163,147,164,148,165,
            149,166,150,167,151,168,152,169,203,220,202,219,201,218,200,217,199,
            216,198,215,197,214,196,213,195,212,194,211,193,210,192,209,191,208,
            190,207,189,206,188,205,187,204,221,238,222,239,223,240,224,241,225,
            242,226,243,227,244,228,245,229,246,230,247,231,248,232,249,233,250,
            234,251,235,252,236,253,237,254,271,288,270,287,269,286,268,285,267,
            284,266,283,265,282,264,281,263,280,262,279,261,278,260,277,259,276,
            258,275,257,274,256,273,255,272
        ]);
    }

    #[test]
    fn test_fill_in_modules() {
        let mut c = Canvas::new(2);
        draw_all_functional_patterns(&mut c);
        c.fill_data_bits([true, false, false].iter().cycle().map(|&b| b));
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######  ..*...*. #######\n\
                    #     #  .*.*.*.* #     #\n\
                    # ### #  *...*... # ### #\n\
                    # ### #  ..*...*. # ### #\n\
                    # ### #  .*.*.*.* # ### #\n\
                    #     #  *...*... #     #\n\
                    ####### # # # # # #######\n\
                 \x20        ..*...*.        \n\
                 \x20     #  .*.*.*.*        \n\
                    ..*.*. .**...*...*..**..*\n\
                    .*.*..#....*...*.........\n\
                    *....* *..*.*.*.*.**..**.\n\
                    ..*.*.#.**...*...*..**..*\n\
                    .*.*.. ....*...*.........\n\
                    *....*#*..*.*.*.*.**..**.\n\
                    ..*.*. .**...*...*..**..*\n\
                    .*.*..#....*...*#####....\n\
                 \x20       #.*.*.*.#   #.**.\n\
                    #######  *...*..# # #*..*\n\
                    #     #  ..*...*#   #....\n\
                    # ### #  .*.*.*.#####.**.\n\
                    # ### #  *...*..*....*..*\n\
                    # ### #  ..*......**.....\n\
                    #     #  .*.*.**.*..*.**.\n\
                    #######  *...*..*....*..*");
    }

    #[test]
    fn test_apply_mask() {
        let mut c = Canvas::new(1);
        draw_all_functional_patterns(&mut c);
        c.fill_data_bits(Bitv::new().iter());
        apply_mask(&mut c, L, Pattern0);

        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    #######  .*.* #######\n\
                    #     #  *.*. #     #\n\
                    # ### # #.*.* # ### #\n\
                    # ### #  *.*. # ### #\n\
                    # ### #  .*.* # ### #\n\
                    #     #  *.*. #     #\n\
                    ####### # # # #######\n\
                 \x20       #*.*.        \n\
                    ### #####.*.*##   #  \n\
                    .*.*.* *.*.*.*.*.*.*.\n\
                    *.*.*.#.*.*.*.*.*.*.*\n\
                    .*.*.* *.*.*.*.*.*.*.\n\
                    *.*.*.#.*.*.*.*.*.*.*\n\
                 \x20       #*.*.*.*.*.*.\n\
                    ####### #.*.*.*.*.*.*\n\
                    #     # #*.*.*.*.*.*.\n\
                    # ### # #.*.*.*.*.*.*\n\
                    # ### #  *.*.*.*.*.*.\n\
                    # ### # #.*.*.*.*.*.*\n\
                    #     # #*.*.*.*.*.*.\n\
                    ####### #.*.*.*.*.*.*");
    }

    fn prepare_canvas_for_penalty_scoring() -> Canvas {
        let mut c = Canvas::new(1);
        let data = bitv::from_bytes(


        b"\x20\x5b\x0b\x78\xd1\x72\xdc\x4d\x43\x40\xec\x11\x00\xa8\x48\x16\x52\xd9\x36\x9c\x00\x2e\x0f\xb4\x7a\x10");
        draw_all_functional_patterns(&mut c);
        c.fill_data_bits(data.iter());
        apply_mask(&mut c, Q, Pattern0);
        c
    }

    #[test]
    fn check_penalty_canvas() {
        let c = prepare_canvas_for_penalty_scoring();
        assert_eq!(c.to_debug_str().as_slice(), "\n\
                    ####### #*... #######\n\
                    #     # #..*. #     #\n\
                    # ### # #..** # ### #\n\
                    # ### # #.... # ### #\n\
                    # ### # #.*.. # ### #\n\
                    #     #  .*.. #     #\n\
                    ####### # # # #######\n\
                 \x20       #....        \n\
                 \x20## # ## ...* # #####\n\
                    .*.... .****....*...*\n\
                    ..**.*#*.**...*.**...\n\
                    .**.** *..**.*.*.***.\n\
                    *...*.#.*.***.***.*.*\n\
                 \x20       #*.*..*...*.*\n\
                    ####### #.*....*.**..\n\
                    #     #  *.**.**.*...\n\
                    # ### # #.*...*******\n\
                    # ### #  *.*.*.*...*.\n\
                    # ### # #...****.*..*\n\
                    #     # #.**.*...*.**\n\
                    #######  ...****....*");
    }

    #[test]
    fn test_penalty_score_adjacent() {
        let c = prepare_canvas_for_penalty_scoring();
        assert_eq!(evaluate_adjacent_penalty(&c, true), 88);
        assert_eq!(evaluate_adjacent_penalty(&c, false), 92);
    }

    #[test]
    fn test_penalty_score_block() {
        let c = prepare_canvas_for_penalty_scoring();
        assert_eq!(evaluate_block_penalty(&c), 90);
    }

    #[test]
    fn test_penalty_score_finder() {
        let c = prepare_canvas_for_penalty_scoring();
        assert_eq!(evaluate_finder_penalty(&c, true), 480);
        assert_eq!(evaluate_finder_penalty(&c, false), 440);
    }

    #[test]
    fn test_penalty_score_proportion() {
        let c = prepare_canvas_for_penalty_scoring();
        assert_eq!(evaluate_proportion_penalty(&c), 2);
    }

    #[test]
    fn test_best_mask() {
        let mut c = Canvas::new(1);
        let data = bitv::from_bytes(b"\x20\x5b\x0b\x78\xd1\x72\xdc\x4d\x43\x40\xec\x11\x00\xa8\x48\x16\x52\xd9\x36\x9c\x00\x2e\x0f\xb4\x7a\x10");
        draw_all_functional_patterns(&mut c);
        c.fill_data_bits(data.iter());

        let c2 = apply_best_mask(&c, Q);

        assert_eq!(c2.to_debug_str().as_slice(), "\n\
                    ####### #*... #######\n\
                    #     # #..*. #     #\n\
                    # ### # #..** # ### #\n\
                    # ### # #.... # ### #\n\
                    # ### # #.*.. # ### #\n\
                    #     #  .*.. #     #\n\
                    ####### # # # #######\n\
                 \x20       #....        \n\
                 \x20## # ## ...* # #####\n\
                    .*.... .****....*...*\n\
                    ..**.*#*.**...*.**...\n\
                    .**.** *..**.*.*.***.\n\
                    *...*.#.*.***.***.*.*\n\
                 \x20       #*.*..*...*.*\n\
                    ####### #.*....*.**..\n\
                    #     #  *.**.**.*...\n\
                    # ### # #.*...*******\n\
                    # ### #  *.*.*.*...*.\n\
                    # ### # #...****.*..*\n\
                    #     # #.**.*...*.**\n\
                    #######  ...****....*");
    }
}

*/

