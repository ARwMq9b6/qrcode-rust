var searchIndex = {};
searchIndex["qrencode"] = {"doc":"","items":[[5,"main","qrencode","",null,{"inputs":[],"output":null}]],"paths":[]};
searchIndex["qrcode"] = {"doc":"QRCode encoder","items":[[3,"QrCode","qrcode","The encoded QR code symbol.",null,null],[0,"types","","",null,null],[4,"QrError","qrcode::types","`QrError` encodes the error encountered when generating a QR code.",null,null],[13,"DataTooLong","","The data is too long to encode into a QR code for the given version.",0,null],[13,"InvalidVersion","","The provided version / error correction level combination is invalid.",0,null],[13,"UnsupportedCharacterSet","","Some characters in the data cannot be supported by the provided QR code\nversion.",0,null],[13,"InvalidEciDesignator","","The provided ECI designator is invalid. A valid designator should be\nbetween 0 and 999999.",0,null],[13,"InvalidCharacter","","A character not belonging to the character set is found.",0,null],[4,"EcLevel","","The error correction level. It allows the original information be recovered\neven if parts of the code is damaged.",null,null],[13,"L","","Low error correction. Allows up to 7% of wrong blocks.",1,null],[13,"M","","Medium error correction (default). Allows up to 15% of wrong blocks.",1,null],[13,"Q","","&quot;Quartile&quot; error correction. Allows up to 25% of wrong blocks.",1,null],[13,"H","","High error correction. Allows up to 30% of wrong blocks.",1,null],[4,"Version","","In QR code terminology, `Version` means the size of the generated image.\nLarger version means the size of code is larger, and therefore can carry\nmore information.",null,null],[13,"Normal","","A normal QR code version. The parameter should be between 1 and 40.",2,null],[13,"Micro","","A Micro QR code version. The parameter should be between 1 and 4.",2,null],[4,"Mode","","The mode indicator, which specifies the character set of the encoded data.",null,null],[13,"Numeric","","The data contains only characters 0 to 9.",3,null],[13,"Alphanumeric","","The data contains only uppercase letters (A–Z), numbers (0–9) and a few\npunctuations marks (space, `$`, `%`, `*`, `+`, `-`, `.`, `/`, `:`).",3,null],[13,"Byte","","The data contains arbitrary binary data.",3,null],[13,"Kanji","","The data contains Shift-JIS-encoded double-byte text.",3,null],[6,"QrResult","","`QrResult` is a convenient alias for a QR code generation result.",null,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"fmt","","",0,null],[11,"fmt","","",0,null],[11,"cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",2,null],[11,"width","","Get the number of &quot;modules&quot; on each size of the QR code, i.e. the width\nand height of the code.",2,null],[11,"fetch","","Obtains an object from a hard-coded table.",2,null],[11,"mode_bits_count","","The number of bits needed to encode the mode indicator.",2,null],[11,"is_micro","","Checks whether is version refers to a Micro QR code.",2,null],[11,"clone","","",3,null],[11,"eq","","",3,null],[11,"fmt","","",3,null],[11,"length_bits_count","","Computes the number of bits needed to encode the data length.",3,null],[11,"data_bits_count","","Computes the number of bits needed to some data of a given raw length.",3,null],[11,"max","","Find the lowest common mode which both modes are compatible with.",3,null],[11,"partial_cmp","","Defines a partial ordering between modes. If `a &lt;= b`, then `b` contains\na superset of all characters supported by `a`.",3,null],[0,"bits","qrcode","The `bits` module encodes binary data into raw bits used in a QR code.",null,null],[3,"Bits","qrcode::bits","The `Bits` structure stores the encoded data for a QR code.",null,null],[4,"ExtendedMode","","An &quot;extended&quot; mode indicator, includes all indicators supported by QR code\nbeyond those bearing data.",null,null],[13,"Eci","","ECI mode indicator, to introduce an ECI designator.",4,null],[13,"Data","","The normal mode to introduce data.",4,null],[13,"Fnc1First","","FNC-1 mode in the first position.",4,null],[13,"Fnc1Second","","FNC-1 mode in the second position.",4,null],[13,"StructuredAppend","","Structured append.",4,null],[5,"encode_auto","","Automatically determines the minimum version to store the data, and encode\nthe result.",null,null],[11,"new","","Constructs a new, empty bits structure.",5,{"inputs":[{"name":"version"}],"output":{"name":"bits"}}],[11,"into_bytes","","Convert the bits into a bytes vector.",5,null],[11,"len","","Total number of bits currently pushed.",5,null],[11,"max_len","","The maximum number of bits allowed by the provided QR code version and\nerror correction level.",5,null],[11,"version","","Version of the QR code.",5,null],[11,"clone","","",4,null],[11,"push_mode_indicator","","Push the mode indicator to the end of the bits.",5,null],[11,"push_eci_designator","","Push an ECI (Extended Channel Interpretation) designator to the bits.",5,null],[11,"push_numeric_data","","Encodes a numeric string to the bits.",5,null],[11,"push_alphanumeric_data","","Encodes an alphanumeric string to the bits.",5,null],[11,"push_byte_data","","Encodes 8-bit byte data to the bits.",5,null],[11,"push_kanji_data","","Encodes Shift JIS double-byte data to the bits.",5,null],[11,"push_fnc1_first_position","","Encodes an indicator that the following data are formatted according to\nthe UCC/EAN Application Identifiers standard.",5,null],[11,"push_fnc1_second_position","","Encodes an indicator that the following data are formatted in accordance\nwith specific industry or application specifications previously agreed\nwith AIM International.",5,null],[11,"push_terminator","","Pushes the ending bits to indicate no more data.",5,null],[11,"push_segments","","Push a segmented data to the bits, and then terminate it.",5,null],[11,"push_optimal_data","","Pushes the data the bits, using the optimal encoding.",5,null],[0,"optimize","qrcode","Find the optimal data mode sequence to encode a piece of data.",null,null],[3,"Segment","qrcode::optimize","A segment of data committed to an encoding mode.",null,null],[12,"mode","","The encoding mode of the segment of data.",6,null],[12,"begin","","The start index of the segment.",6,null],[12,"end","","The end index (exclusive) of the segment.",6,null],[3,"Parser","","QR code data parser to classify the input into distinct segments.",null,null],[3,"Optimizer","","",null,null],[5,"total_encoded_len","","Computes the total encoded length of all segments.",null,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"encoded_len","","Compute the number of bits (including the size of the mode indicator and\nlength bits) when this segment is encoded.",6,null],[11,"new","","Creates a new iterator which parse the data into segments that only\ncontains their exclusive subsets. No optimization is done at this point.",7,null],[11,"next","","",7,null],[11,"new","","Optimize the segments by combining adjacent segments when possible.",8,{"inputs":[{"name":"i"},{"name":"version"}],"output":{"name":"optimizer"}}],[11,"optimize","","",7,null],[11,"next","","",8,null],[0,"ec","qrcode","The `ec` module applies the Reed-Solomon error correction codes.",null,null],[5,"create_error_correction_code","qrcode::ec","Creates the error correction code in N bytes.",null,null],[5,"construct_codewords","","Constructs data and error correction codewords ready to be put in the QR\ncode matrix.",null,null],[5,"max_allowed_errors","","Computes the maximum allowed number of erratic modules can be introduced to\nthe QR code, before the data becomes truly corrupted.",null,{"inputs":[{"name":"version"},{"name":"eclevel"}],"output":{"name":"qrresult"}}],[0,"canvas","qrcode","The `canvas` module puts raw bits into the QR code canvas.",null,null],[3,"Canvas","qrcode::canvas","`Canvas` is an intermediate helper structure to render error-corrected data\ninto a QR code.",null,null],[4,"Module","","The color of a module (pixel) in the QR code.",null,null],[13,"Empty","","The module is empty.",9,null],[13,"Light","","The module is light (white), and cannot be masked. This mainly refers to\nmodules of functional patterns.",9,null],[13,"Dark","","The module is dark (black), and cannot be masked. This mainly refers to\nmodules of functional patterns.",9,null],[13,"LightUnmasked","","The module is light (white), but not yet masked. This mainly refers to\nmodules of data and error correction bits before masking.",9,null],[13,"DarkUnmasked","","The module is dark (black), but not yet masked. This mainly refers to\nmodules of data and error correction bits before masking.",9,null],[4,"MaskPattern","","The mask patterns. Since QR code and Micro QR code do not use the same\npattern number, we name them according to their shape instead of the number.",null,null],[13,"Checkerboard","","QR code pattern 000: `(x + y) % 2 == 0`.",10,null],[13,"HorizontalLines","","QR code pattern 001: `y % 2 == 0`.",10,null],[13,"VerticalLines","","QR code pattern 010: `x % 3 == 0`.",10,null],[13,"DiagonalLines","","QR code pattern 011: `(x + y) % 3 == 0`.",10,null],[13,"LargeCheckerboard","","QR code pattern 100: `((x/3) + (y/2)) % 2 == 0`.",10,null],[13,"Fields","","QR code pattern 101: `(x*y)%2 + (x*y)%3 == 0`.",10,null],[13,"Diamonds","","QR code pattern 110: `((x*y)%2 + (x*y)%3) % 2 == 0`.",10,null],[13,"Meadow","","QR code pattern 111: `((x+y)%2 + (x*y)%3) % 2 == 0`.",10,null],[5,"is_functional","","Gets whether the module at the given coordinates represents a functional\nmodule.",null,{"inputs":[{"name":"version"},{"name":"i16"},{"name":"i16"},{"name":"i16"}],"output":{"name":"bool"}}],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"eq","","",9,null],[11,"is_dark","","Checks whether a module is dark.",9,null],[11,"mask","","Apply a mask to the unmasked modules.",9,null],[11,"clone","","",11,null],[11,"new","","Constructs a new canvas big enough for a QR code of the given version.",11,{"inputs":[{"name":"version"},{"name":"eclevel"}],"output":{"name":"canvas"}}],[11,"get","","Obtains a module at the given coordinates. For convenience, negative\ncoordinates will wrap around.",11,null],[11,"get_mut","","Obtains a mutable module at the given coordinates. For convenience,\nnegative coordinates will wrap around.",11,null],[11,"put","","Sets the color of a module at the given coordinates. For convenience,\nnegative coordinates will wrap around.",11,null],[11,"draw_all_functional_patterns","","Draw all functional patterns, before data placement.",11,null],[11,"draw_data","","Draws the encoded data and error correction codes to the empty modules.",11,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"apply_mask","","Applies a mask to the canvas. This method will also draw the format info\npatterns.",11,null],[11,"apply_best_mask","","Construct a new canvas and apply the best masking that gives the lowest\npenalty score.",11,null],[11,"to_bools","","Convert the modules into a vector of booleans.",11,null],[0,"render","qrcode","Render a QR code into image.",null,null],[3,"Renderer","qrcode::render","A QR code renderer. This is a builder type which converts a bool-vector into\nan image.",null,null],[8,"BlankAndWhitePixel","","A pixel which can support black and white colors.",null,null],[10,"black_color","","",12,{"inputs":[],"output":{"name":"self"}}],[10,"white_color","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"black_color","image::color","",13,{"inputs":[],"output":{"name":"self"}}],[11,"white_color","","",13,{"inputs":[],"output":{"name":"self"}}],[11,"black_color","","",14,{"inputs":[],"output":{"name":"self"}}],[11,"white_color","","",14,{"inputs":[],"output":{"name":"self"}}],[11,"black_color","","",15,{"inputs":[],"output":{"name":"self"}}],[11,"white_color","","",15,{"inputs":[],"output":{"name":"self"}}],[11,"black_color","","",16,{"inputs":[],"output":{"name":"self"}}],[11,"white_color","","",16,{"inputs":[],"output":{"name":"self"}}],[11,"new","qrcode::render","Creates a new renderer.",17,null],[11,"dark_color","","Sets color of a dark module. Default is opaque black.",17,null],[11,"light_color","","Sets color of a light module. Default is opaque white.",17,null],[11,"quiet_zone","","Whether to include the quiet zone in the generated image.",17,null],[11,"module_size","","Sets the size of each module in pixels. Default is 8px.",17,null],[11,"min_width","","Sets the minimal total image width (and thus height) in pixels,\nincluding the quiet zone if applicable. The renderer will try to find\nthe dimension as small as possible, such that each module in the QR code\nhas uniform size (no distortion).",17,null],[11,"to_image","","Renders the QR code into an image.",17,null],[11,"clone","qrcode","",18,null],[11,"new","","Constructs a new QR code which automatically encodes the given data.",18,{"inputs":[{"name":"d"}],"output":{"name":"qrresult"}}],[11,"with_error_correction_level","","Constructs a new QR code which automatically encodes the given data at a\nspecific error correction level.",18,{"inputs":[{"name":"d"},{"name":"eclevel"}],"output":{"name":"qrresult"}}],[11,"with_version","","Constructs a new QR code for the given version and error correction\nlevel.",18,{"inputs":[{"name":"d"},{"name":"version"},{"name":"eclevel"}],"output":{"name":"qrresult"}}],[11,"with_bits","","Constructs a new QR code with encoded bits.",18,{"inputs":[{"name":"bits"},{"name":"eclevel"}],"output":{"name":"qrresult"}}],[11,"version","","Gets the version of this QR code.",18,null],[11,"error_correction_level","","Gets the error correction level of this QR code.",18,null],[11,"width","","Gets the number of modules per side, i.e. the width of this QR code.",18,null],[11,"max_allowed_errors","","Gets the maximum number of allowed erratic modules can be introduced\nbefore the data becomes corrupted. Note that errors should not be\nintroduced to functional modules.",18,null],[11,"is_functional","","Checks whether a module at coordinate (x, y) is a functional module or\nnot.",18,null],[11,"to_debug_str","","Converts the QR code into a human-readable string. This is mainly for\ndebugging only.",18,null],[11,"to_vec","","Converts the QR code to a vector of booleans. Each entry represents the\ncolor of the module, with &quot;true&quot; means dark and &quot;false&quot; means light.",18,null],[11,"into_vec","","Converts the QR code to a vector of booleans. Each entry represents the\ncolor of the module, with &quot;true&quot; means dark and &quot;false&quot; means light.",18,null],[11,"render","","Renders the QR code into an image. The result is an image builder, which\nyou may do some additional configuration before copying it into a\nconcrete image.",18,null],[11,"index","","",18,null]],"paths":[[4,"QrError"],[4,"EcLevel"],[4,"Version"],[4,"Mode"],[4,"ExtendedMode"],[3,"Bits"],[3,"Segment"],[3,"Parser"],[3,"Optimizer"],[4,"Module"],[4,"MaskPattern"],[3,"Canvas"],[8,"BlankAndWhitePixel"],[3,"Rgb"],[3,"Rgba"],[3,"Luma"],[3,"LumaA"],[3,"Renderer"],[3,"QrCode"]]};
initSearch(searchIndex);
